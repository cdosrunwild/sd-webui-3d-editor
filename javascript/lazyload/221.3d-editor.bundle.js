"use strict";(self.webpackChunksd_webui_3d_editor=self.webpackChunksd_webui_3d_editor||[]).push([[221],{9221:function(t,e,a){a.r(e),a.d(e,{LDrawLoader:function(){return M}});var r=a(9477);const n="16",i="24",o=r.KI_,s=new r.Pa4,l=new r.Pa4;class c extends r.jyz{constructor(t){super({uniforms:r.rDY.merge([r.rBU.fog,{diffuse:{value:new r.Ilk},opacity:{value:1}}]),vertexShader:"\n\t\t\t\tattribute vec3 control0;\n\t\t\t\tattribute vec3 control1;\n\t\t\t\tattribute vec3 direction;\n\t\t\t\tvarying float discardFlag;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <color_pars_vertex>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <color_vertex>\n\n\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\t// Transform the line segment ends and control points into camera clip space\n\t\t\t\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\t\t\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\t\t\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\t\t\t\tc0.xy /= c0.w;\n\t\t\t\t\tc1.xy /= c1.w;\n\t\t\t\t\tp0.xy /= p0.w;\n\t\t\t\t\tp1.xy /= p1.w;\n\n\t\t\t\t\t// Get the direction of the segment and an orthogonal vector\n\t\t\t\t\tvec2 dir = p1.xy - p0.xy;\n\t\t\t\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t\t\t\t// Get control point directions from the line\n\t\t\t\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\t\t\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t\t\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t\t\t\t// from the line segment then the line should not be drawn.\n\t\t\t\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\t\t\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\t\t\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\t\t\tuniform vec3 diffuse;\n\t\t\tuniform float opacity;\n\t\t\tvarying float discardFlag;\n\n\t\t\t#include <common>\n\t\t\t#include <color_pars_fragment>\n\t\t\t#include <fog_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t#include <clipping_planes_pars_fragment>\n\t\t\tvoid main() {\n\n\t\t\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t\t\t#include <clipping_planes_fragment>\n\t\t\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t#include <color_fragment>\n\t\t\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <encodings_fragment>\n\t\t\t\t#include <fog_fragment>\n\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t}\n\t\t\t"}),Object.defineProperties(this,{opacity:{get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},color:{get:function(){return this.uniforms.diffuse.value}}}),this.setValues(t),this.isLDrawConditionalLineMaterial=!0}}class d extends r.ejS{constructor(t,e){super(t,e),this.isConditionalLine=!0}}const h=new r.zHn;function u(t){return"Part"===t||"Unofficial_Part"===t}class g{constructor(t,e){this.line=t,this.lineLength=t.length,this.currentCharIndex=0,this.currentChar=" ",this.lineNumber=e}seekNonSpace(){for(;this.currentCharIndex<this.lineLength;){if(this.currentChar=this.line.charAt(this.currentCharIndex)," "!==this.currentChar&&"\t"!==this.currentChar)return;this.currentCharIndex++}}getToken(){const t=this.currentCharIndex++;for(;this.currentCharIndex<this.lineLength&&(this.currentChar=this.line.charAt(this.currentCharIndex)," "!==this.currentChar&&"\t"!==this.currentChar);)this.currentCharIndex++;const e=this.currentCharIndex;return this.seekNonSpace(),this.line.substring(t,e)}getVector(){return new r.Pa4(parseFloat(this.getToken()),parseFloat(this.getToken()),parseFloat(this.getToken()))}getRemainingString(){return this.line.substring(this.currentCharIndex,this.lineLength)}isAtTheEnd(){return this.currentCharIndex>=this.lineLength}setToEnd(){this.currentCharIndex=this.lineLength}getLineNumberString(){return this.lineNumber>=0?" at line "+this.lineNumber:""}}class m{constructor(t){this.loader=t,this._cache={}}cloneResult(t){const e={};return e.faces=t.faces.map((t=>({colorCode:t.colorCode,material:t.material,vertices:t.vertices.map((t=>t.clone())),normals:t.normals.map((()=>null)),faceNormal:null}))),e.conditionalSegments=t.conditionalSegments.map((t=>({colorCode:t.colorCode,material:t.material,vertices:t.vertices.map((t=>t.clone())),controlPoints:t.controlPoints.map((t=>t.clone()))}))),e.lineSegments=t.lineSegments.map((t=>({colorCode:t.colorCode,material:t.material,vertices:t.vertices.map((t=>t.clone()))}))),e.type=t.type,e.category=t.category,e.keywords=t.keywords,e.author=t.author,e.subobjects=t.subobjects,e.fileName=t.fileName,e.totalFaces=t.totalFaces,e.startingBuildingStep=t.startingBuildingStep,e.materials=t.materials,e.group=null,e}async fetchData(t){let e=!1,a=0;for(;6!==a;){let n=t;switch(a){case 3:a+=1;break;case 0:n="parts/"+n,a+=1;break;case 1:n="p/"+n,a+=1;break;case 2:n="models/"+n,a+=1;break;case 4:n=t.substring(0,t.lastIndexOf("/")+1)+n,a+=1;break;case 5:e?a=6:(n=t=t.toLowerCase(),e=!0,a=0)}const i=this.loader,o=new r.hH6(i.manager);o.setPath(i.partsLibraryPath),o.setRequestHeader(i.requestHeader),o.setWithCredentials(i.withCredentials);try{return await o.loadAsync(n)}catch{continue}}throw new Error('LDrawLoader: Subobject "'+t+'" could not be loaded.')}parse(t,e=null){const a=this.loader,n=[],i=[],o=[],s=[],l={},c=t=>l[t]||null;let d="Model",h=null,u=null,m=null,p=0;-1!==t.indexOf("\r\n")&&(t=t.replace(/\r\n/g,"\n"));const f=t.split("\n"),C=f.length;let w=!1,M=null,b=null,y=!1,k=!0,L=!1,v=!0,E=!1;for(let t=0;t<C;t++){const e=f[t];if(0===e.length)continue;if(w){e.startsWith("0 FILE ")?(this.setData(M,b),M=e.substring(7),b=""):b+=e+"\n";continue}const C=new g(e,t+1);if(C.seekNonSpace(),C.isAtTheEnd())continue;const x=C.getToken();let D,T,S,_,N,F,A,I,V,P,W;switch(x){case"0":const e=C.getToken();if(e)switch(e){case"!LDRAW_ORG":d=C.getToken();break;case"!COLOUR":D=a.parseColorMetaDirective(C),D?l[D.userData.code]=D:console.warn("LDrawLoader: Error parsing material"+C.getLineNumberString());break;case"!CATEGORY":h=C.getToken();break;case"!KEYWORDS":const e=C.getRemainingString().split(",");e.length>0&&(u||(u=[]),e.forEach((function(t){u.push(t.trim())})));break;case"FILE":t>0&&(w=!0,M=C.getRemainingString(),b="",y=!1,k=!0);break;case"BFC":for(;!C.isAtTheEnd();){const t=C.getToken();switch(t){case"CERTIFY":case"NOCERTIFY":y="CERTIFY"===t,k=!0;break;case"CW":case"CCW":k="CCW"===t;break;case"INVERTNEXT":L=!0;break;case"CLIP":case"NOCLIP":v="CLIP"===t;break;default:console.warn('THREE.LDrawLoader: BFC directive "'+t+'" is unknown.')}}break;case"STEP":E=!0;break;case"Author:":m=C.getToken()}break;case"1":T=C.getToken(),D=c(T);const g=parseFloat(C.getToken()),f=parseFloat(C.getToken()),R=parseFloat(C.getToken()),z=parseFloat(C.getToken()),O=parseFloat(C.getToken()),j=parseFloat(C.getToken()),B=parseFloat(C.getToken()),U=parseFloat(C.getToken()),H=parseFloat(C.getToken()),G=parseFloat(C.getToken()),q=parseFloat(C.getToken()),Y=parseFloat(C.getToken()),$=(new r.yGw).set(z,O,j,g,B,U,H,f,G,q,Y,R,0,0,0,1);let K=C.getRemainingString().trim().replace(/\\/g,"/");a.fileMap[K]?K=a.fileMap[K]:K.startsWith("s/")?K="parts/"+K:K.startsWith("48/")&&(K="p/"+K),s.push({material:D,colorCode:T,matrix:$,fileName:K,inverted:L,startingBuildingStep:E}),E=!1,L=!1;break;case"2":T=C.getToken(),D=c(T),F=C.getVector(),A=C.getVector(),S={material:D,colorCode:T,vertices:[F,A]},i.push(S);break;case"5":T=C.getToken(),D=c(T),F=C.getVector(),A=C.getVector(),P=C.getVector(),W=C.getVector(),S={material:D,colorCode:T,vertices:[F,A],controlPoints:[P,W]},o.push(S);break;case"3":T=C.getToken(),D=c(T),_=k,N=!y||!v,!0===_?(F=C.getVector(),A=C.getVector(),I=C.getVector()):(I=C.getVector(),A=C.getVector(),F=C.getVector()),n.push({material:D,colorCode:T,faceNormal:null,vertices:[F,A,I],normals:[null,null,null]}),p++,!0===N&&(n.push({material:D,colorCode:T,faceNormal:null,vertices:[I,A,F],normals:[null,null,null]}),p++);break;case"4":T=C.getToken(),D=c(T),_=k,N=!y||!v,!0===_?(F=C.getVector(),A=C.getVector(),I=C.getVector(),V=C.getVector()):(V=C.getVector(),I=C.getVector(),A=C.getVector(),F=C.getVector()),n.push({material:D,colorCode:T,faceNormal:null,vertices:[F,A,I,V],normals:[null,null,null,null]}),p+=2,!0===N&&(n.push({material:D,colorCode:T,faceNormal:null,vertices:[V,I,A,F],normals:[null,null,null,null]}),p+=2);break;default:throw new Error('LDrawLoader: Unknown line type "'+x+'"'+C.getLineNumberString()+".")}}return w&&this.setData(M,b),{faces:n,conditionalSegments:o,lineSegments:i,type:d,category:h,keywords:u,author:m,subobjects:s,totalFaces:p,startingBuildingStep:E,materials:l,fileName:e,group:null}}getData(t,e=!0){const a=t.toLowerCase(),r=this._cache[a];return null===r||r instanceof Promise?null:e?this.cloneResult(r):r}async ensureDataLoaded(t){const e=t.toLowerCase();e in this._cache||(this._cache[e]=this.fetchData(t).then((a=>{const r=this.parse(a,t);return this._cache[e]=r,r}))),await this._cache[e]}setData(t,e){const a=t.toLowerCase();this._cache[a]=this.parse(e,t)}}function p(t,e,a,r){return(!r&&t===n||r&&t===i)&&(t=e),a[t]||null}class f{constructor(t){this.loader=t,this.parseCache=new m(t),this._cache={}}async processIntoMesh(t){const e=this.loader,a=this.parseCache,o=new Set,c=async(t,s=null)=>{const l=t.subobjects,d=[];for(let t=0,e=l.length;t<e;t++){const e=l[t],r=a.ensureDataLoaded(e.fileName).then((()=>{return t=a.getData(e.fileName,!1).type,/primitive/i.test(t)||"Subpart"===t?c(a.getData(e.fileName),e):this.loadModel(e.fileName).catch((t=>(console.warn(t),null)));var t}));d.push(r)}const h=new r.ZAu;h.userData.category=t.category,h.userData.keywords=t.keywords,h.userData.author=t.author,h.userData.type=t.type,h.userData.fileName=t.fileName,t.group=h;const u=await Promise.all(d);for(let a=0,r=u.length;a<r;a++){const r=t.subobjects[a],s=u[a];if(null===s)continue;if(s.isGroup){const a=s;r.matrix.decompose(a.position,a.quaternion,a.scale),a.userData.startingBuildingStep=r.startingBuildingStep,a.name=r.fileName,e.applyMaterialsToMesh(a,r.colorCode,t.materials),a.userData.colorCode=r.colorCode,h.add(a);continue}s.group.children.length&&h.add(s.group);const l=t.lineSegments,c=t.conditionalSegments,d=t.faces,g=s.lineSegments,m=s.conditionalSegments,f=s.faces,C=r.matrix,w=r.inverted,M=C.determinant()<0,b=r.colorCode,y=b===n?i:b;for(let e=0,a=g.length;e<a;e++){const a=g[e],r=a.vertices;r[0].applyMatrix4(C),r[1].applyMatrix4(C),a.colorCode=a.colorCode===i?y:a.colorCode,a.material=a.material||p(a.colorCode,a.colorCode,t.materials,!0),l.push(a)}for(let e=0,a=m.length;e<a;e++){const a=m[e],r=a.vertices,n=a.controlPoints;r[0].applyMatrix4(C),r[1].applyMatrix4(C),n[0].applyMatrix4(C),n[1].applyMatrix4(C),a.colorCode=a.colorCode===i?y:a.colorCode,a.material=a.material||p(a.colorCode,a.colorCode,t.materials,!0),c.push(a)}for(let e=0,a=f.length;e<a;e++){const a=f[e],r=a.vertices;for(let t=0,e=r.length;t<e;t++)r[t].applyMatrix4(C);a.colorCode=a.colorCode===n?b:a.colorCode,a.material=a.material||p(a.colorCode,b,t.materials,!1),o.add(a.colorCode),M!==w&&r.reverse(),d.push(a)}t.totalFaces+=s.totalFaces}return s&&(e.applyMaterialsToMesh(h,s.colorCode,t.materials),h.userData.colorCode=s.colorCode),t};for(let e=0,a=t.faces;e<a;e++)o.add(t.faces[e].colorCode);if(await c(t),e.smoothNormals){const e=o.size>1;!function(t){for(let e=0,a=t.length;e<a;e++){const a=t[e],n=a.vertices,i=n[0],o=n[1],c=n[2];s.subVectors(o,i),l.subVectors(c,o),a.faceNormal=(new r.Pa4).crossVectors(s,l).normalize()}}(t.faces),function(t,e,a=!1){const n=100*(1+1e-10);function i(t){return`${~~(t.x*n)},${~~(t.y*n)},${~~(t.z*n)}`}function o(t,e){return`${i(t)}_${i(e)}`}function s(t,e,a){a.direction.subVectors(e,t).normalize();const r=t.dot(a.direction);return a.origin.copy(t).addScaledVector(a.direction,-r),a}function l(t){return o(t.origin,t.direction)}const c=new Set,d=new Map,u={},g=[];for(let t=0,n=e.length;t<n;t++){const n=e[t].vertices,i=n[0],h=n[1];if(c.add(o(i,h)),c.add(o(h,i)),a){const t=s(i,h,new r.zHn),e=l(t);if(!d.has(e)){s(h,i,t);const a=l(t),r={ray:t,distances:[]};d.set(e,r),d.set(a,r)}const a=d.get(e);let n=a.ray.direction.dot(i),o=a.ray.direction.dot(h);n>o&&([n,o]=[o,n]),a.distances.push(n,o)}}for(let e=0,r=t.length;e<r;e++){const r=t[e],n=r.vertices,i=n.length;for(let t=0;t<i;t++){const e=t,g=(t+1)%i,m=n[e],p=n[g],f=o(m,p);if(c.has(f))continue;if(a){s(m,p,h);const t=l(h);if(d.has(t)){const e=d.get(t),{ray:a,distances:r}=e;let n=a.direction.dot(m),i=a.direction.dot(p);n>i&&([n,i]=[i,n]);let o=!1;for(let t=0,e=r.length;t<e;t+=2)if(n>=r[t]&&i<=r[t+1]){o=!0;break}if(o)continue}}const C={index:e,tri:r};u[f]=C}}for(;;){let t=null;for(const e in u){t=u[e];break}if(null===t)break;const e=[t];for(;e.length>0;){const t=e.pop().tri,a=t.vertices,n=t.normals,i=t.faceNormal,s=a.length;for(let l=0;l<s;l++){const c=l,d=(l+1)%s,h=a[c],m=a[d];delete u[o(h,m)];const p=o(m,h),f=u[p];if(f){const a=f.tri,o=f.index,s=a.normals,l=s.length,h=a.faceNormal;if(Math.abs(a.faceNormal.dot(t.faceNormal))<.25)continue;p in u&&(e.push(f),delete u[p]);const m=(o+1)%l;n[c]&&s[m]&&n[c]!==s[m]&&(s[m].norm.add(n[c].norm),n[c].norm=s[m].norm);let C=n[c]||s[m];null===C&&(C={norm:new r.Pa4},g.push(C.norm)),null===n[c]&&(n[c]=C,C.norm.add(i)),null===s[m]&&(s[m]=C,C.norm.add(h)),n[d]&&s[o]&&n[d]!==s[o]&&(s[o].norm.add(n[d].norm),n[d].norm=s[o].norm);let w=n[d]||s[o];null===w&&(w={norm:new r.Pa4},g.push(w.norm)),null===n[d]&&(n[d]=w,w.norm.add(i)),null===s[o]&&(s[o]=w,w.norm.add(h))}}}}for(let t=0,e=g.length;t<e;t++)g[t].normalize()}(t.faces,t.lineSegments,e)}const d=t.group;return t.faces.length>0&&d.add(w(t.faces,3,!1,t.totalFaces)),t.lineSegments.length>0&&d.add(w(t.lineSegments,2)),t.conditionalSegments.length>0&&d.add(w(t.conditionalSegments,2,!0)),d}hasCachedModel(t){return null!==t&&t.toLowerCase()in this._cache}async getCachedModel(t){if(null!==t&&this.hasCachedModel(t)){const e=t.toLowerCase();return(await this._cache[e]).clone()}return null}async loadModel(t){const e=this.parseCache,a=t.toLowerCase();if(this.hasCachedModel(t))return this.getCachedModel(t);{await e.ensureDataLoaded(t);const r=e.getData(t),n=this.processIntoMesh(r);return this.hasCachedModel(t)?this.getCachedModel(t):(u(r.type)&&(this._cache[a]=n),(await n).clone())}}async parseModel(t){const e=this.parseCache.parse(t);return u(e.type)&&this.hasCachedModel(e.fileName)?this.getCachedModel(e.fileName):this.processIntoMesh(e)}}function C(t,e){return t.colorCode===e.colorCode?0:t.colorCode<e.colorCode?-1:1}function w(t,e,a=!1,n=null){t.sort(C),null===n&&(n=t.length);const i=new Float32Array(e*n*3),o=3===e?new Float32Array(e*n*3):null,c=[],h=new Array(6),u=new r.u9r;let g=null,m=0,p=0,f=0;for(let n=0,d=t.length;n<d;n++){const d=t[n];let C=d.vertices;4===C.length&&(h[0]=C[0],h[1]=C[1],h[2]=C[2],h[3]=C[0],h[4]=C[2],h[5]=C[3],C=h);for(let t=0,e=C.length;t<e;t++){const e=C[t],a=f+3*t;i[a+0]=e.x,i[a+1]=e.y,i[a+2]=e.z}if(3===e){if(!d.faceNormal){const t=C[0],e=C[1],a=C[2];s.subVectors(e,t),l.subVectors(a,e),d.faceNormal=(new r.Pa4).crossVectors(s,l).normalize()}let t=d.normals;4===t.length&&(h[0]=t[0],h[1]=t[1],h[2]=t[2],h[3]=t[0],h[4]=t[2],h[5]=t[3],t=h);for(let e=0,a=t.length;e<a;e++){let a=d.faceNormal;t[e]&&(a=t[e].norm);const r=f+3*e;o[r+0]=a.x,o[r+1]=a.y,o[r+2]=a.z}}if(g!==d.colorCode){null!==g&&u.addGroup(m,p,c.length-1);const t=d.material;null!==t?3===e?c.push(t):2===e&&(a?c.push(t.userData.edgeMaterial.userData.conditionalEdgeMaterial):c.push(t.userData.edgeMaterial)):c.push(d.colorCode),g=d.colorCode,m=f/3,p=C.length}else p+=C.length;f+=3*C.length}p>0&&u.addGroup(m,1/0,c.length-1),u.setAttribute("position",new r.TlE(i,3)),null!==o&&u.setAttribute("normal",new r.TlE(o,3));let w=null;if(2===e?w=a?new d(u,1===c.length?c[0]:c):new r.ejS(u,1===c.length?c[0]:c):3===e&&(w=new r.Kj0(u,1===c.length?c[0]:c)),a){w.isConditionalLine=!0;const e=new Float32Array(3*t.length*2),a=new Float32Array(3*t.length*2),n=new Float32Array(3*t.length*2);for(let r=0,i=t.length;r<i;r++){const i=t[r],o=i.vertices,s=i.controlPoints,l=s[0],c=s[1],d=o[0],h=o[1],u=3*r*2;e[u+0]=l.x,e[u+1]=l.y,e[u+2]=l.z,e[u+3]=l.x,e[u+4]=l.y,e[u+5]=l.z,a[u+0]=c.x,a[u+1]=c.y,a[u+2]=c.z,a[u+3]=c.x,a[u+4]=c.y,a[u+5]=c.z,n[u+0]=h.x-d.x,n[u+1]=h.y-d.y,n[u+2]=h.z-d.z,n[u+3]=h.x-d.x,n[u+4]=h.y-d.y,n[u+5]=h.z-d.z}u.setAttribute("control0",new r.TlE(e,3,!1)),u.setAttribute("control1",new r.TlE(a,3,!1)),u.setAttribute("direction",new r.TlE(n,3,!1))}return w}class M extends r.aNw{constructor(t){super(t),this.materials=[],this.materialLibrary={},this.partsCache=new f(this),this.fileMap={},this.setMaterials([]),this.smoothNormals=!0,this.partsLibraryPath="",this.missingColorMaterial=new r.Wid({color:16711935,roughness:.3,metalness:0}),this.missingColorMaterial.name="Missing material",this.missingEdgeColorMaterial=new r.nls({color:16711935}),this.missingEdgeColorMaterial.name="Missing material - Edge",this.missingConditionalEdgeColorMaterial=new c({fog:!0,color:16711935}),this.missingConditionalEdgeColorMaterial.name="Missing material - Conditional Edge",this.missingColorMaterial.userData.edgeMaterial=this.missingEdgeColorMaterial,this.missingEdgeColorMaterial.userData.conditionalEdgeMaterial=this.missingConditionalEdgeColorMaterial}setPartsLibraryPath(t){return this.partsLibraryPath=t,this}async preloadMaterials(t){const e=new r.hH6(this.manager);e.setPath(this.path),e.setRequestHeader(this.requestHeader),e.setWithCredentials(this.withCredentials);const a=/^0 !COLOUR/,n=(await e.loadAsync(t)).split(/[\n\r]/g),i=[];for(let t=0,e=n.length;t<e;t++){const e=n[t];if(a.test(e)){const t=e.replace(a,""),r=this.parseColorMetaDirective(new g(t));i.push(r)}}this.setMaterials(i)}load(t,e,a,i){const o=new r.hH6(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,(a=>{this.partsCache.parseModel(a,this.materialLibrary).then((a=>{this.applyMaterialsToMesh(a,n,this.materialLibrary,!0),this.computeBuildingSteps(a),a.userData.fileName=t,e(a)})).catch(i)}),a,i)}parse(t,e){this.partsCache.parseModel(t,this.materialLibrary).then((t=>{this.applyMaterialsToMesh(t,n,this.materialLibrary,!0),this.computeBuildingSteps(t),t.userData.fileName="",e(t)}))}setMaterials(t){this.materialLibrary={},this.materials=[];for(let e=0,a=t.length;e<a;e++)this.addMaterial(t[e]);return this.addMaterial(this.parseColorMetaDirective(new g("Main_Colour CODE 16 VALUE #FF8080 EDGE #333333"))),this.addMaterial(this.parseColorMetaDirective(new g("Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333"))),this}setFileMap(t){return this.fileMap=t,this}addMaterial(t){const e=this.materialLibrary;return e[t.userData.code]||(this.materials.push(t),e[t.userData.code]=t),this}getMaterial(t){if(t.startsWith("0x2")){const e=t.substring(3);return this.parseColorMetaDirective(new g("Direct_Color_"+e+" CODE -1 VALUE #"+e+" EDGE #"+e))}return this.materialLibrary[t]||null}applyMaterialsToMesh(t,e,a,r=!1){const o=this,s=e===n;function l(t,l){if(s&&!(l in a)&&!r)return l;const c=t.isLineSegments||t.isConditionalLine;(!c&&l===n||c&&l===i)&&(l=e);let d=null;if(l in a)d=a[l];else{if(!r)return l;d=o.getMaterial(l),null===d&&(console.warn(`LDrawLoader: Material properties for code ${l} not available.`),d=o.missingColorMaterial)}return t.isLineSegments&&(d=d.userData.edgeMaterial,t.isConditionalLine&&(d=d.userData.conditionalEdgeMaterial)),d}t.traverse((t=>{if(t.isMesh||t.isLineSegments)if(Array.isArray(t.material))for(let e=0,a=t.material.length;e<a;e++)t.material[e].isMaterial||(t.material[e]=l(t,t.material[e]));else t.material.isMaterial||(t.material=l(t,t.material))}))}getMainMaterial(){return this.getMaterial(n)}getMainEdgeMaterial(){const t=this.getMaterial(i);return t?t.userData.edgeMaterial:null}parseColorMetaDirective(t){let e=null,a="#FF00FF",n="#FF00FF",i=1,s=!1,l=0,d=0,h=null;const u=t.getToken();if(!u)throw new Error('LDrawLoader: Material name was expected after "!COLOUR tag'+t.getLineNumberString()+".");let m=null;for(;m=t.getToken(),m;)if(!f(m))switch(m.toUpperCase()){case"CODE":e=t.getToken();break;case"VALUE":if(a=t.getToken(),a.startsWith("0x"))a="#"+a.substring(2);else if(!a.startsWith("#"))throw new Error("LDrawLoader: Invalid color while parsing material"+t.getLineNumberString()+".");break;case"EDGE":if(n=t.getToken(),n.startsWith("0x"))n="#"+n.substring(2);else if(!n.startsWith("#")){if(h=this.getMaterial(n),!h)throw new Error("LDrawLoader: Invalid edge color while parsing material"+t.getLineNumberString()+".");h=h.userData.edgeMaterial}break;case"ALPHA":if(i=parseInt(t.getToken()),isNaN(i))throw new Error("LDrawLoader: Invalid alpha value in material definition"+t.getLineNumberString()+".");i=Math.max(0,Math.min(1,i/255)),i<1&&(s=!0);break;case"LUMINANCE":if(!f(t.getToken()))throw new Error("LDrawLoader: Invalid luminance value in material definition"+g.getLineNumberString()+".");break;case"CHROME":d=1;break;case"PEARLESCENT":d=2;break;case"RUBBER":d=3;break;case"MATTE_METALLIC":d=4;break;case"METAL":d=5;break;case"MATERIAL":t.setToEnd();break;default:throw new Error('LDrawLoader: Unknown token "'+m+'" while parsing material'+t.getLineNumberString()+".")}let p=null;switch(d){case 0:p=new r.Wid({roughness:.3,metalness:0});break;case 2:p=new r.Wid({roughness:.3,metalness:.25});break;case 1:p=new r.Wid({roughness:0,metalness:1});break;case 3:p=new r.Wid({roughness:.9,metalness:0});break;case 4:p=new r.Wid({roughness:.8,metalness:.4});break;case 5:p=new r.Wid({roughness:.2,metalness:.85})}return p.color.setStyle(a,o),p.transparent=s,p.premultipliedAlpha=!0,p.opacity=i,p.depthWrite=!s,p.polygonOffset=!0,p.polygonOffsetFactor=1,0!==l&&p.emissive.setStyle(a,o).multiplyScalar(l),h||(h=new r.nls({color:(new r.Ilk).setStyle(n,o),transparent:s,opacity:i,depthWrite:!s}),h.color,h.userData.code=e,h.name=u+" - Edge",h.userData.conditionalEdgeMaterial=new c({fog:!0,transparent:s,depthWrite:!s,color:(new r.Ilk).setStyle(n,o),opacity:i}),h.userData.conditionalEdgeMaterial.userData.code=e,h.userData.conditionalEdgeMaterial.name=u+" - Conditional Edge"),p.userData.code=e,p.name=u,p.userData.edgeMaterial=h,this.addMaterial(p),p;function f(t){let e;return e=t.startsWith("LUMINANCE")?parseInt(t.substring(9)):parseInt(t),!isNaN(e)&&(l=Math.max(0,Math.min(1,e/255)),!0)}}computeBuildingSteps(t){let e=0;t.traverse((t=>{t.isGroup&&(t.userData.startingBuildingStep&&e++,t.userData.buildingStep=e)})),t.userData.numBuildingSteps=e+1}}}}]);