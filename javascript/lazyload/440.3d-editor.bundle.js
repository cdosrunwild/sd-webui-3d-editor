"use strict";(self.webpackChunksd_webui_3d_editor=self.webpackChunksd_webui_3d_editor||[]).push([[440],{4440:function(t,n,e){e.r(n),e.d(n,{USDZExporter:function(){return a}});var o=e(9477),r=e(8646);class a{async parse(t,n={}){n=Object.assign({ar:{anchoring:{type:"plane"},planeAnchoring:{alignment:"horizontal"}},quickLookCompatible:!1},n);const e={},o="model.usda";e[o]=null;let a='#usda 1.0\n(\n\tcustomLayerData = {\n\t\tstring creator = "Three.js USDZExporter"\n\t}\n\tmetersPerUnit = 1\n\tupAxis = "Y"\n)\n\n';a+=function(t){return`def Xform "Root"\n{\n\tdef Scope "Scenes" (\n\t\tkind = "sceneLibrary"\n\t)\n\t{\n\t\tdef Xform "Scene" (\n\t\t\tcustomData = {\n\t\t\t\tbool preliminary_collidesWithEnvironment = 0\n\t\t\t\tstring sceneName = "Scene"\n\t\t\t}\n\t\t\tsceneName = "Scene"\n\t\t)\n\t\t{\n\t\ttoken preliminary:anchoring:type = "${t.ar.anchoring.type}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${t.ar.planeAnchoring.alignment}"\n\n`}(n);const l={},d={};t.traverseVisible((t=>{if(t.isMesh){const n=t.geometry,o=t.material;if(o.isMeshStandardMaterial){const i="geometries/Geometry_"+n.id+".usda";if(!(i in e)){const t=function(t){const n=function(t){const n=t.attributes,e=n.position.count;return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(t){const n=null!==t.index?t.index.count:t.attributes.position.count;return Array(n/3).fill(3).join(", ")}(t)}]\n\t\tint[] faceVertexIndices = [${function(t){const n=t.index,e=[];if(null!==n)for(let t=0;t<n.count;t++)e.push(n.getX(t));else{const n=t.attributes.position.count;for(let t=0;t<n;t++)e.push(t)}return e.join(", ")}(t)}]\n\t\tnormal3f[] normals = [${c(n.normal,e)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${c(n.position,e)}]\n${function(t,n){let e="";for(let o=0;o<4;o++){const r=o>0?o:"",a=t["uv"+r];void 0!==a&&(e+=`\n\t\ttexCoord2f[] primvars:st${r} = [${p(a,n)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}return e}(n,e)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}(t);return`\ndef "Geometry"\n{\n${n}\n}\n`}(n);e[i]=function(t){let n='#usda 1.0\n(\n\tcustomLayerData = {\n\t\tstring creator = "Three.js USDZExporter"\n\t}\n\tmetersPerUnit = 1\n\tupAxis = "Y"\n)\n\n';return n+=t,r.TD(n)}(t)}o.uuid in l||(l[o.uuid]=o),a+=function(t,n,e){const o="Object_"+t.id,r=u(t.matrixWorld);return t.matrixWorld.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",t),`def Xform "${o}" (\n\tprepend references = @./geometries/Geometry_${n.id}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${r}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\trel material:binding = </Materials/Material_${e.id}>\n}\n\n`}(t,n,o)}else console.warn("THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)",t)}else t.isCamera&&(a+=function(t){const n=t.name?t.name:"Camera_"+t.id,e=u(t.matrixWorld);return t.matrixWorld.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",t),t.isOrthographicCamera?`def Camera "${n}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${e}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${t.near.toPrecision(s)}, ${t.far.toPrecision(s)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(t.left)+Math.abs(t.right))).toPrecision(s)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(t.top)+Math.abs(t.bottom))).toPrecision(s)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`:`def Camera "${n}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${e}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${t.near.toPrecision(s)}, ${t.far.toPrecision(s)})\n\t\t\tfloat focalLength = ${t.getFocalLength().toPrecision(s)}\n\t\t\tfloat focusDistance = ${t.focus.toPrecision(s)}\n\t\t\tfloat horizontalAperture = ${t.getFilmWidth().toPrecision(s)}\n\t\t\ttoken projection = "perspective"\n\t\t\tfloat verticalAperture = ${t.getFilmHeight().toPrecision(s)}\n\t\t}\n\t\n\t`}(t))})),a+="\n\t\t}\n\t}\n}\n\n",a+=function(t,n,e=!1){const o=[];for(const r in t){const a=t[r];o.push(f(a,n,e))}return`def "Materials"\n{\n${o.join("")}\n}\n\n`}(l,d,n.quickLookCompatible),e[o]=r.TD(a),a=null;for(const t in d){const n=d[t],o=i(n.image,n.flipY),r=await new Promise((t=>o.toBlob(t,"image/png",1)));e[`textures/Texture_${t}.png`]=new Uint8Array(await r.arrayBuffer())}let m=0;for(const t in e){const n=e[t];m+=34+t.length;const o=63&m;if(4!==o){const r=new Uint8Array(64-o);e[t]=[n,{extra:{12345:r}}]}m=n.length}return r.Xo(e,{level:0})}}function i(t,n){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const e=1024/Math.max(t.width,t.height),o=document.createElement("canvas");o.width=t.width*Math.min(1,e),o.height=t.height*Math.min(1,e);const r=o.getContext("2d");return!0===n&&(r.translate(0,o.height),r.scale(1,-1)),r.drawImage(t,0,0,o.width,o.height),o}throw new Error("THREE.USDZExporter: No valid image data found. Unable to process texture.")}const s=7;function u(t){const n=t.elements;return`( ${l(n,0)}, ${l(n,4)}, ${l(n,8)}, ${l(n,12)} )`}function l(t,n){return`(${t[n+0]}, ${t[n+1]}, ${t[n+2]}, ${t[n+3]})`}function c(t,n){if(void 0===t)return console.warn("USDZExporter: Normals missing."),Array(n).fill("(0, 0, 0)").join(", ");const e=[];for(let n=0;n<t.count;n++){const o=t.getX(n),r=t.getY(n),a=t.getZ(n);e.push(`(${o.toPrecision(s)}, ${r.toPrecision(s)}, ${a.toPrecision(s)})`)}return e.join(", ")}function p(t,n){if(void 0===t)return console.warn("USDZExporter: UVs missing."),Array(n).fill("(0, 0)").join(", ");const e=[];for(let n=0;n<t.count;n++){const o=t.getX(n),r=t.getY(n);e.push(`(${o.toPrecision(s)}, ${1-r.toPrecision(s)})`)}return e.join(", ")}function f(t,n,e=!1){const r="\t\t\t",a=[],i=[];function u(r,a,i){const u=r.source.id+"_"+r.flipY;n[u]=r;const l=r.channel>0?"st"+r.channel:"st",c={1e3:"repeat",1001:"clamp",1002:"mirror"},p=r.repeat.clone(),f=r.offset.clone(),d=r.rotation,h=Math.sin(d),$=Math.cos(d);return f.y=1-f.y-p.y,e?(f.x=f.x/p.x,f.y=f.y/p.y,f.x+=h/p.x,f.y+=$-1):(f.x+=h*p.x,f.y+=(1-$)*p.y),`\n\t\tdef Shader "PrimvarReader_${a}"\n\t\t{\n\t\t\tuniform token info:id = "UsdPrimvarReader_float2"\n\t\t\tfloat2 inputs:fallback = (0.0, 0.0)\n\t\t\ttoken inputs:varname = "${l}"\n\t\t\tfloat2 outputs:result\n\t\t}\n\n\t\tdef Shader "Transform2d_${a}"\n\t\t{\n\t\t\tuniform token info:id = "UsdTransform2d"\n\t\t\ttoken inputs:in.connect = </Materials/Material_${t.id}/PrimvarReader_${a}.outputs:result>\n\t\t\tfloat inputs:rotation = ${(d*(180/Math.PI)).toFixed(s)}\n\t\t\tfloat2 inputs:scale = ${m(p)}\n\t\t\tfloat2 inputs:translation = ${m(f)}\n\t\t\tfloat2 outputs:result\n\t\t}\n\n\t\tdef Shader "Texture_${r.id}_${a}"\n\t\t{\n\t\t\tuniform token info:id = "UsdUVTexture"\n\t\t\tasset inputs:file = @textures/Texture_${u}.png@\n\t\t\tfloat2 inputs:st.connect = </Materials/Material_${t.id}/Transform2d_${a}.outputs:result>\n\t\t\t${void 0!==i?"float4 inputs:scale = "+function(t){return`(${t.r}, ${t.g}, ${t.b}, 1.0)`}(i):""}\n\t\t\ttoken inputs:sourceColorSpace = "${r.colorSpace===o.aCh?"raw":"sRGB"}"\n\t\t\ttoken inputs:wrapS = "${c[r.wrapS]}"\n\t\t\ttoken inputs:wrapT = "${c[r.wrapT]}"\n\t\t\tfloat outputs:r\n\t\t\tfloat outputs:g\n\t\t\tfloat outputs:b\n\t\t\tfloat3 outputs:rgb\n\t\t\t${t.transparent||t.alphaTest>0?"float outputs:a":""}\n\t\t}`}return t.side===o.ehD&&console.warn("THREE.USDZExporter: USDZ does not support double sided materials",t),null!==t.map?(a.push(`${r}color3f inputs:diffuseColor.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:rgb>`),t.transparent?a.push(`${r}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`):t.alphaTest>0&&(a.push(`${r}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`),a.push(`${r}float inputs:opacityThreshold = ${t.alphaTest}`)),i.push(u(t.map,"diffuse",t.color))):a.push(`${r}color3f inputs:diffuseColor = ${d(t.color)}`),null!==t.emissiveMap?(a.push(`${r}color3f inputs:emissiveColor.connect = </Materials/Material_${t.id}/Texture_${t.emissiveMap.id}_emissive.outputs:rgb>`),i.push(u(t.emissiveMap,"emissive"))):t.emissive.getHex()>0&&a.push(`${r}color3f inputs:emissiveColor = ${d(t.emissive)}`),null!==t.normalMap&&(a.push(`${r}normal3f inputs:normal.connect = </Materials/Material_${t.id}/Texture_${t.normalMap.id}_normal.outputs:rgb>`),i.push(u(t.normalMap,"normal"))),null!==t.aoMap&&(a.push(`${r}float inputs:occlusion.connect = </Materials/Material_${t.id}/Texture_${t.aoMap.id}_occlusion.outputs:r>`),i.push(u(t.aoMap,"occlusion"))),null!==t.roughnessMap&&1===t.roughness?(a.push(`${r}float inputs:roughness.connect = </Materials/Material_${t.id}/Texture_${t.roughnessMap.id}_roughness.outputs:g>`),i.push(u(t.roughnessMap,"roughness"))):a.push(`${r}float inputs:roughness = ${t.roughness}`),null!==t.metalnessMap&&1===t.metalness?(a.push(`${r}float inputs:metallic.connect = </Materials/Material_${t.id}/Texture_${t.metalnessMap.id}_metallic.outputs:b>`),i.push(u(t.metalnessMap,"metallic"))):a.push(`${r}float inputs:metallic = ${t.metalness}`),null!==t.alphaMap?(a.push(`${r}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.alphaMap.id}_opacity.outputs:r>`),a.push(`${r}float inputs:opacityThreshold = 0.0001`),i.push(u(t.alphaMap,"opacity"))):a.push(`${r}float inputs:opacity = ${t.opacity}`),t.isMeshPhysicalMaterial&&(a.push(`${r}float inputs:clearcoat = ${t.clearcoat}`),a.push(`${r}float inputs:clearcoatRoughness = ${t.clearcoatRoughness}`),a.push(`${r}float inputs:ior = ${t.ior}`)),`\n\tdef Material "Material_${t.id}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${a.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${t.id}/PreviewSurface.outputs:surface>\n\n${i.join("\n")}\n\n\t}\n`}function d(t){return`(${t.r}, ${t.g}, ${t.b})`}function m(t){return`(${t.x}, ${t.y})`}}}]);